import os
import pandas as pd
from mcp.server.fastmcp import FastMCP
from toast_api_client import ToastAPIClient

# Importing helper functions from utils
from utils.tools_utils import get_date_range

# Loading api credentials from environment variables
from dotenv import load_dotenv
load_dotenv()

TOAST_CLIENT_ID = os.getenv("TOAST_CLIENT_ID")
TOAST_CLIENT_SECRET = os.getenv("TOAST_CLIENT_SECRET")
TOAST_API_BASE_URL = os.getenv("TOAST_API_BASE_URL")
TOAST_RESTAURANT_GUID = os.getenv("TOAST_RESTAURANT_GUID")

if not TOAST_API_BASE_URL:
    raise ValueError("Missing TOAST_API_BASE_URL environment variable. Please set it in your .env file.")

# Initialize MCP Server
mcp = FastMCP("toast-mcp-server")

# Initialize a ToastAPIClient object
client = ToastAPIClient(base_url=TOAST_API_BASE_URL,
                        client_id=TOAST_CLIENT_ID,
                        client_secret=TOAST_CLIENT_SECRET,
                        restaurant_guid=TOAST_RESTAURANT_GUID)

# Adding first tool: get_sales_summary()
@mcp.tool()
async def get_sales_summary(start_date: str, end_date: str, restaurant: str | None = None) -> dict|None:
    """
    Uses ToastAPIClient to use method "get_orders(start_date, end_date)" sales data 
    of orders within a timeframe. This tool calculates the total number of revenue, number 
    of items sold, and a list of individual sold items with the number of quanitity sold 
    and the total revenue it brought. And if requested, this will only be done to filter

    Parameters:
        start_date(str): Beginning date of timeframe in the ISO-8601 format
        end_date(str): Ending date of timeframe in the ISO-8601 format
        restaurant(str|None): If requested, this will only give the sales data of a 
                              specific restaurant

    Returns:
       sales_info_dict(dict): A dictionary containing summarized sales information with the following keys:
            - total_revenue (float): The total revenue from all items sold within the timeframe, rounded to 2 decimal places.
            - total_items_sold (int): The total number of items sold (count of all order rows).
            - items (list[dict]): A list of dictionaries, each representing a unique item sold with:
                - item_name (str): The name of the item.
                - quantity_sold (int): The number of times the item was sold.
                - total_revenue (float): The total revenue generated by that item.
    """
    
    # Use API Client to get a pandas DataFrame of all the orders between (startDate, endDate)
    orders_df = await client.get_orders(start_date, end_date)

    # If no orders are returned, return None
    if orders_df is None:
        return None

    # If wanting to filter by restaurant, get only items sold at that restaurant
    if restaurant:
        orders_df = orders_df.loc[orders_df["restaurant_name"].str.lower() == restaurant.lower(), :]

    # Get total number of revenue, which is the sum of all prices of items sold
    total_revenue = round(float(orders_df["item_price"].sum()),2) # Rounding it to 2 decimal places

    # Get number of items sold (total rows in DataFrame)
    total_items_sold = orders_df.shape[0]

    # Use Pandas groupby unique items and calculate number of items sold (quantity) and total revenue by item
    grouped = (
        orders_df.groupby("item_name")
        .agg(quantity_sold=("item_name", "count"),
             total_revenue=("item_price", "sum"))
        .reset_index()
    )

    # Convert grouped DataFrame to list of dicts
    items = grouped.to_dict(orient="records")

    # Initializing dict output
    sales_info_dict = {
        "total_revenue": total_revenue,
        "total_items_sold": total_items_sold,
        "items": items
    }

    return sales_info_dict

# Adding second tool: get_top_items()
@mcp.tool()
async def get_top_items(days: int, limit: int = 5, restaurant: str | None = None) -> dict|None:
    """
    Uses ToastAPIClient to fetch orders within the last `days` days and returns the top-selling items.
    This tool calculates the quantity sold and total revenue for each item, ranks them, and returns
    the top `limit` items. If requested, results can be filtered for a specific restaurant.

    Parameters:
        days (int): Number of days in the past to include in the analysis (e.g., 7 for last week).
        limit (int, optional): Maximum number of top items to return. Defaults to 5.
        restaurant (str|None, optional): If provided, only include sales data for the specified restaurant.

    Returns:
        top_items_dict (dict): A dictionary containing the period analyzed and a list of top items with the following keys:
            - period (str): A human-readable string describing the timeframe analyzed (e.g., "Last 7 days").
            - top_items (list[dict]): A list of dictionaries, each representing a top-selling item with:
                - item_name (str): The name of the item.
                - quantity_sold (int): The number of times the item was sold.
                - total_revenue (float): The total revenue generated by that item.
                - rank (int): The rank of the item based on quantity sold (1 = highest).
    """
    
    # Configuring start_date and end_date using current date and time in ISO-8601 format
    start_date, end_date = get_date_range(days=days)
    
    # Use API Client to get a pandas DataFrame of all the orders between (startDate, endDate)
    orders_df = await client.get_orders(start_date, end_date)

    # If no orders are returned, return None
    if orders_df is None:
        return None
    
    if restaurant:
        orders_df = orders_df.loc[orders_df["restaurant_name"].str.lower() == restaurant.lower(), :]
    
    # Use Pandas groupby unique items and calculate number of items sold (quantity) and total revenue by item
    grouped = (
        orders_df.groupby("item_name")
        .agg(quantity_sold=("item_name", "count"),
             total_revenue=("item_price", "sum"))
        .reset_index()
    )

    # Add rank by quantity sold (descending)
    grouped["rank"] = grouped["quantity_sold"].rank(method="dense", ascending=False).astype(int)

    # Sort by quantity sold descending; get the greatest selling first
    grouped = grouped.sort_values(by="quantity_sold", ascending=False)

    # Limit results
    grouped = grouped.head(limit)

    # Convert grouped DataFrame to list of dicts
    top_items = grouped.to_dict(orient="records")

    top_items_dict = {"period": f"Last {days} days",
                      "top_items": top_items}

    return top_items_dict

# Adding third tool: get_product_mix()
@mcp.tool()
async def get_product_mix(start_date: str, end_date: str, restaurant: str | None = None) -> dict|None:
    """
    Uses ToastAPIClient to fetch orders within a specified timeframe and calculates the product mix
    by grouping items into their respective item groups. This tool summarizes the quantity sold and
    total revenue for each product group. If requested, results can be filtered for a specific restaurant.

    Parameters:
        start_date (str): Beginning date of timeframe in the ISO-8601 format.
        end_date (str): Ending date of timeframe in the ISO-8601 format.
        restaurant (str|None, optional): If provided, only include sales data for the specified restaurant.

    Returns:
        item_groups (dict): A dictionary keyed by item group name, where each value is a dictionary with:
            - quantity_sold (int): The number of items sold in this group.
            - total_revenue (float): The total revenue generated by this group.
    """
    # Use API Client to get a pandas DataFrame of all the orders between (startDate, endDate)
    orders_df = await client.get_orders(start_date, end_date)

    # If no orders are returned, return None
    if orders_df is None:
        return None

    # If wanting to filter by restaurant, get only items sold at that restaurant
    if restaurant:
        orders_df = orders_df.loc[orders_df["restaurant_name"].str.lower() == restaurant.lower(), :]

    # Use Pandas groupby unique items and calculate number of items sold (quantity) and total revenue by item
    grouped = (
        orders_df.groupby("item_group_name")
        .agg(quantity_sold=("item_group_name", "count"),
             total_revenue=("item_price", "sum"))
        .reset_index()
    )

    # Convert grouped DataFrame to dictionary keyed by item_group_name
    item_groups = grouped.set_index("item_group_name").to_dict(orient="index")

    return item_groups

@mcp.resource("toast://menus")
async def get_menus_resource() -> list[dict]:
    """
    MCP Resource that exposes the ToastTab Menus as a list of dictionaries.
    Each dictionary represents a menu item with its details.
    """
    menus_df = await client.get_menus()
    if menus_df is None or menus_df.empty:
        return []
    return menus_df.to_dict(orient="records")

if __name__ == "__main__":
    # Initialize and run the server
    mcp.run(transport='stdio')
